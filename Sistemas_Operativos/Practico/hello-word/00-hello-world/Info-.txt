
# Info Que Saque yo para entenderlo mejor


2. Proceso de Arranque en RISC-V
2.1. Secuencia de Boot
    Modo Machine (M-mode):
        Cuando se enciende la placa, la CPU inicia en el modo máquina (M-mode), el cual permite ejecutar código privilegiado.
        La CPU comienza ejecutando el código del Zero Stage Bootloader (ZSBL) que se encuentra en ROM o FLASH de la placa.

    Carga del Kernel:
        El bootloader se encarga de cargar la imagen del kernel desde un dispositivo de almacenamiento principal 
        (en QEMU, se especifica mediante la opción -kernel <kernel-image>) en la dirección de memoria física 0x80000000.

    Transferencia de Control:
        Una vez cargado el kernel en memoria, el bootloader hace un jump (salto) a la dirección 0x80000000, donde se encuentra la función boot(). 
        Esta función es el punto de entrada en el kernel.



3. Detalle del Código Fuente
    3.1. Archivo kernel.c

    Función console_putc(char ch):
        Esta función envía un carácter individual al UART. Antes de escribir en el THR, espera a que el bit 6 del LSR (UART_STATUS_EMPTY) se active, 
        lo que indica que el THR está vacío y listo para recibir otro carácter.

    Función console_puts(const char *s):
        Envía una cadena de caracteres al llamar secuencialmente a console_putc() para cada carácter de la cadena.

    Función kernel_main()
    Mensaje Inicial:
        Al ejecutarse, el kernel invoca console_puts() para enviar el mensaje "Hello World!\n" a la consola, 
        lo que permitirá visualizarlo en una terminal conectada al UART.

    Bucle Infinito:
        Después de imprimir el mensaje, el kernel entra en un bucle infinito (for (;;) { }). 
        Esto es común en kernels básicos para mantener el sistema funcionando y evitar que se caiga la ejecución tras terminar el código principal.






1. ¿De dónde proviene la dirección 0x80000000?
    Configuración del sistema RISC-V:
        En muchas implementaciones y emuladores (como QEMU para RISC-V), se suele configurar la memoria física (la RAM) para que inicie en la dirección 0x80000000.


Linker Script:
    En el linker script (kernel.ld) se especifica que el comienzo de la sección .text (código ejecutable) es justamente en 0x80000000. 
    Esto establece en qué dirección se debe cargar y ejecutar la imagen del kernel.


2. ¿Qué es la "memoria física"?
    RAM (Memoria de Acceso Aleatorio):
        En este contexto, la "memoria física" se refiere a la RAM, que es la memoria volátil utilizada por el sistema para ejecutar programas. 
        Después del arranque, el kernel se ejecuta desde la RAM.

    ROM (Memoria de Solo Lectura):
        La ROM es normalmente utilizada para almacenar el firmware o el bootloader (por ejemplo, el ZSBL en RISC-V) que se encarga de realizar la carga inicial
        del sistema.

    Diferenciación:
    El bootloader que se encuentra en ROM carga el kernel desde un medio de almacenamiento (como una imagen en disco o similar) 
    y lo coloca en la RAM en la dirección 0x80000000. Una vez cargado, el CPU salta a esa dirección y ejecuta el kernel.


    La imagen del kernel se carga en la "memoria física" del sistema emulado (la RAM virtual de QEMU) en la dirección 0x80000000.

    Esa memoria es parte de la asignación de recursos de tu PC, pero no es la memoria física en el mismo sentido que tu PC organiza su propia RAM.

3. ¿Por qué arranca ahí?
    Convención y Simplicidad en el Diseño:
    Se elige 0x80000000 como el inicio de la RAM en muchas arquitecturas RISC-V por cuestiones de diseño y convenciones en la organización de la memoria. 
    Esto facilita la gestión y el mapeo de dispositivos de hardware (como el UART) que se encuentran en otras direcciones de la memoria.

    Facilita el Proceso de Arranque:
    El bootloader, al cargar la imagen del kernel, sabe exactamente dónde colocarla en la memoria (en la dirección base establecida), 
    lo que simplifica la transferencia de control al kernel una vez cargado.

    Compatibilidad con QEMU y Otras Plataformas:
    En entornos de emulación como QEMU, se configura que la memoria RAM del sistema virtual comience en 0x80000000, 
    de modo que el kernel se cargue en una región de memoria de la que se tiene pleno control y acceso, evitando posibles conflictos con otros mapeos.